# Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라

## 장점

1. 이름을 가질 수 있다.

`BigInteger.probablePrime()` vs `new BigInteger(int, int, Random)`

정적 팩토리 메소드를 사용하면, "값 소수인 BigInteger를 반환한다." 그 의미가 분명하기 드러난다.

2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.

내부 Pool을 사용하여 인스턴스를 캐싱이 가능하다. 그 예로 `Boolean.valueOf(boolean)`가 있다.

3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

Interface에 정적 메소드로 팩토리 메소드를 구현하면, 구현체를 감추고 클라이언트에게 제공 가능하다. 이는 API를 작게 만드는데, 클라이언트가 느끼는 API의 개념적 무게가 구현체에서 인터페이스로 축소되기 때문이다. `java.utils.Collections`에서 `List.of()`가 그 예 중에 하나다. List의 구현이 어떤 것인지 모르지만, List 인터페이스를 알기에 사용법을 익히기 쉽다.
	
EnumSet은 enum 요소가 64개에 대한  set 집합 정보를 long의 비트를 이용하여 표현하는데, enum 요소가 64개 이하일 때는 long 하나로 표현하고 64개 이상일 때는 long 배열로 표현한다. 이는 EnumSet 구현 방식이 다르다는 걸 의미하며 RegularEnumSet (long), JumboEnumSet (long 배열)로 구분 되어 있다. 사실 4번이 말하고자 하는 바가 3번과 크게 달라보이지 않는다.

5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

서비스 제공자 프레임워크 3개의 핵심 컴포넌트

- 서비스 인터페이스(service inteface): 구현체 동작을 정의. Connection
- 제공자 등록 API(provider registration API): 제공자가 구현체를 등록할 때 사용 DriverManager.registerDriver
- 서비스 접근 API(service access API): 클라이언트가 서비스의 인터페이스를 획득 DriverManager.getConnection

```java
// 1. registerDriver
Connection conn = DriverManager.registerDriver(new com.mysql.jdbc.Driver());

// 2. getConnection
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", "username", "password");
```

제공자 등록 API는 구현체 인스턴스를 직접 넣어줘야 하고 서비스 접근 API는 구현체 생성 방식을 inteface한다. 서비스 접근 API에서는 실제 클라이언트는 구현체가 어떤 모습인지 모른다.


## 단점

1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.

2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

`new [class name]()` 방식의 생성은 일괄적으로 객체를 인스턴스화 하기에 생성자를 찾기가 편한데, 정적 팩터리 메서드는 API doc을 참조하거나 개발자의 의도를 이해해야 한다.

# Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라

생성자에 매개변수가 많을 때 사용할 수 있는 패턴이 여러 개 있다. 그중에 대표적으로 Builder 패턴을 가장 많이 쓴다. 

Builder 패턴은 점층적 생성자 패턴과 자바빈 패턴의 장점을 취한 패턴이다. 먼저 점층적 생성자 패턴과 자바빈 패턴의 문제점을 알아보고 Builder 패턴의 장점을 알아보자.

점층적 생성자 패턴은 매개변수가 많은 생성자가 적은 생성자를 wrapping해서 구현하는 방식이다. 직관적이라는 장점이 있지만 결국 생성자의 인터페이스 제한을 뛰어 넘지 못하기 때문에 매개변수 입력 값을 모두 확인하여 코드를 이해 해야한다. 즉 클라이언트 측의 가독성이 좋지 않다고 얘기할 수 있다. 반면에 자바빈 패턴은 setter를 이용해서 기본 생성자로 생성한 인스턴스에 값을 변경하여 초기화하는 방식이다. 이는 객체의 불변이 깨지는 지점이 생기고 일관성을 유지할 수 없다는 단점이 있다.

반면 Builder 패턴은 클라이언트에서 아래와 같은 패턴으로 사용된다.

```java
NutritionFacts nutritionFacts = NutritionFacts.builder()
                .servingSize(1)
                .servings(3)
                .calories(0)
                .fat(0)
                .carbohydrate(0)
                .sodium(0)
                .build();
```

각 매개 변수를 메소드로 할당하여 값을 입력하여 가독성을 높였고 최종적으로 build() 호출로 인스턴스를 생성하여 생성 단계 이후에 객체의 불변을 유지할 수 있다. Builder 패턴의 구현은 내부 정적 클래스를 선언하여 구현할 수 있다.

# Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

기본적으로 생성자 private으로 두어서 생성자로 인스턴스가 추가 생성되는 것을 방지한다. 싱글톤 인스턴스를 클라이언트에 제공하는 방식은 여러가지가 있다.

- public static final 필드에 인스턴스를 생성하여 제공
- 정적 메소드로 인스턴스 제공

첫번째 방법은 싱글톤임을 API를 통해서 분명하게 드러낸다. 하지만 두번째 방법은 정적 메소드로 인터페이스하기 때문에 여러 기능을 제공할 수 있다. 예를 들어서 스레드 별로 다른 인스턴스를 제공하거나 제너릭 싱글톤을 생성할 수 있다.

하지만 싱글턴 직렬화 시에 역직렬화 할 때 새로운 인스턴스가 생성되는 문제가 있다. 이를 방지하기 위해 인스턴스 필드를 transient로 선언하고 readResolve 메소드로 인스턴스를 제공해야한다. (역직렬화 시에 readResolve 리턴값으로 readObject 결과를 대체하고 대체 . readObject 결과는 GC 대상이 된다.)

열거 타입으로 싱글톤을 생성할 수 있는데, 이는 직렬화에서 발생할 수 있는 문제나 리플렉션으로 private 메소드를 강제 호출하여 인스턴스를 생성하는 공격 모두 방지할 수 있다. (Enum 타입의 상수 값은 싱글톤임을 보장하고 있고 직렬화가 암시적으로 선언되어 있다)

# Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

java.lang.Math와 java.util.Arrays 같이 static method를 모아 놓은 클래스가 있다. static method를 모아 놓는 것은 객체 지향적 설계에서는 주의해야 하지만 때론 유용할 때가 있다. 이런 경우에는 인스턴스화를 막는 것이 좋은데, 인스턴스화를 막는 방법 중에 가장 좋은 방법은 기본 생성자를 private으로 설정하고 주석을 달아주는 것이다. 추상 클래스도 인스턴스화를 막기는 하지만, 상속하여 인스턴스화할 수 있기 때문에 완전히 막는 것은 불가능하다. 그리고 추상 클래스는 상속을 유도하기 때문에 더욱더 좋지 않다.

# Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

Dependency Injection(DI)는 사실상 DI 프레임워크인 Spring framework을 공부할 때 열심히 본 개념이다. 의존성 주입은 구현의 생성에 대한 책임을 외부로 넘기면서 객체의 구현 의존성을 끊어서 재사용성과 유연성 테스트 용이성을 개선해주는 개념이다.

# Item 6. 불필요한 객체 생성을 피하라

객체 생성의 비용의 차이는 큰 성능 차이를 만들어낸다.

1. String 리터널로 인스턴스 재사용
```java
String string = new String("Lucky Vicky") // 매번 새로운 객체를 생성
String string = "Lucky Vicky" // String Pool에 인스턴스를 이후에 재사용 가능
```

2. 정규 표현식 패턴 인스턴스 생성
```java
Long sum = 0L
for (int i = 0; i < 100; i++){
	sum += i;
}
```
박싱된 기본 타입일 때 형변환으로 매번 Long 객체를 생성하는 비효율이 존재한다. 이때는 long 기본 타입을 사용할 때 성능 개선의 효과를 볼 수 있다.

# Item 7. 다 쓴 객체 참조를 해제하라

메모리를 자동으로 관리해주는 GC 덕분에 java를 편하게 사용할 수 있지만, GC의 대상이 되지 않아 메모리 누수가 발생하여 프로그램이 예기치 않게 종료될 때가 있다. 크게 3가지 상황에서 발생할 수 있다.

*메모리 누수는 OOM(out of memory)를 발생시켜 프로그램을 예기치 못하게 종료시키거나 디스크 페이징(디스크를 메모리로 사용하는 기법)으로 성능을 저하시킨다. 이는 힙 프로파일러로 디버그 할 때 발견되기도 한다.

1. 메모리를 자체적으로 관리하는 객체

대표적으로 Stack이 있다. Stack은 ArrayList를 내부적으로 가지며 Stack 내부 메모리 크기를 초과하면 ArrayList를 2배 늘려서 사용한다. 그리고 내부에 참조됐던 객체들은 GC에서 수거 대상인지 아닌지 판단하기 힘들다.

사용하지 않는 객체에 null 참조로 변경하는 것으로 GC의 대상이 되도록 할 수 있다. 하지만 이는 예외적인 경우에서만 사용하고 일반적으로는 변수를 사용하는 범위를 제한하는 것으로 조치할 수 있다.

2. 캐시

Key를 참조할 때만 Key-value가 살아있어야 한다면, WeakHashMap으로 캐시를 구현하자. Key 참조가 끝나면 즉시 GC의 대상이 될 것이다.

3. 리스너와 콜백

리스너와 콜백을 명확히 해지해주지 않는 것도 메모리 누수의 원인이다. WeakReference로 등록할 경우에 GC의 대상이 되게 할 수 있다.

*만약 어떤 객체가 WeakReference만 가지고 있다면, 가비지 컬렉터는 그 객체를 더 이상 사용되지 않는다고 판단
